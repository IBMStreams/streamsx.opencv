/*
 * # Licensed Materials - Property of IBM
 * # Copyright IBM Corp. 2012
 * # US Government Users Restricted Rights - Use, duplication or
 * # disclosure restricted by GSA ADP Schedule Contract with
 * # IBM Corp.
 */

/* Additional includes go here */

<%SPL::CodeGen::implementationPrologue($model);%>

<%
# Set up commonly used variables, includes, and requires
my $modelroot = $model->getContext()->getOperatorDirectory();
unshift @INC, dirname($modelroot) . "/Common";

use strict;
require opencv;
require util;
import opencv;
import util;

my $opername = $model->getContext()->getKind(); 

my $inputPort = $model->getInputPortAt(0);

my $display = $model->getParameterByName("display") ? $model->getParameterByName("display")->getValueAt(0)->getCppExpression() : undef;
my $title = $model->getParameterByName("title") ? $model->getParameterByName("title")->getValueAt(0)->getCppExpression() : undef;
my $skip = $model->getParameterByName("skip") ? $model->getParameterByName("skip")->getValueAt(0)->getCppExpression() : 0;

my $widthAttribute = "";
$widthAttribute = "iport\$0.get_ipl_width()" if $model->getInputPortAt(0)->getAttributeByName("ipl_width");
$widthAttribute = $model->getParameterByName("widthAttribute")->getValueAt(0)->getCppExpression() if $model->getParameterByName("widthAttribute");
SPL::CodeGen::error("image width not specified by parameter or input attribute") unless $widthAttribute;
#print STDERR "widthAttribute=$widthAttribute\n";

my $heightAttribute = "";
$heightAttribute = "iport\$0.get_ipl_height()" if $model->getInputPortAt(0)->getAttributeByName("ipl_height");
$heightAttribute = $model->getParameterByName("heightAttribute")->getValueAt(0)->getCppExpression() if $model->getParameterByName("heightAttribute");
SPL::CodeGen::error("image height not specified by parameter or input attribute") unless $heightAttribute;
#print STDERR "heightAttribute=$heightAttribute\n";

my $depthAttribute = "8";
$depthAttribute = "iport\$0.get_ipl_depth()" if $model->getInputPortAt(0)->getAttributeByName("ipl_depth");
$depthAttribute = $model->getParameterByName("depthAttribute")->getValueAt(0)->getCppExpression() if $model->getParameterByName("depthAttribute");
#print STDERR "depthAttribute=$depthAttribute\n";

my $channelsAttribute = "3";
$channelsAttribute = "iport\$0.get_ipl_channels()" if $model->getInputPortAt(0)->getAttributeByName("ipl_channels");
$channelsAttribute = $model->getParameterByName("channelsAttribute")->getValueAt(0)->getCppExpression() if $model->getParameterByName("channelsAttribute");
#print STDERR "channelsAttribute=$channelsAttribute\n";

my $dataAttribute = "";
$dataAttribute = "iport\$0.get_ipl_data()" if $model->getInputPortAt(0)->getAttributeByName("ipl_data");
$dataAttribute = $model->getParameterByName("dataAttribute")->getValueAt(0)->getCppExpression() if $model->getParameterByName("dataAttribute");
SPL::CodeGen::error("image data not specified by parameter or input attribute") unless $dataAttribute;
#print STDERR "dataAttribute=$dataAttribute\n";

my $dataAttributeType = "";
$dataAttributeType = $model->getInputPortAt(0)->getAttributeByName("ipl_data")->getSPLType() if $model->getInputPortAt(0)->getAttributeByName("ipl_data");
$dataAttributeType = $model->getParameterByName("dataAttribute")->getValueAt(0)->getSPLType() if $model->getParameterByName("dataAttribute");
SPL::CodeGen::error("image data type not 'list<uint8>") unless $dataAttributeType eq "list<uint8>";
#print STDERR "dataAttributeType=$dataAttributeType\n";

%>

#undef LOG_INFO // conflict with syslog
#include <opencv.h>
#include <mutex.h>

using namespace std;
using namespace dpssupport::opencv;
using namespace dpssupport::mutex;

#define DBG_ASP "opencv"

// Constructor
MY_OPERATOR::MY_OPERATOR() 
  : MY_BASE_OPERATOR(),
    _image_count(0),
    _shutdown(false),
    _skip(0)
{
    SPLLOG(L_TRACE, "Entering " <%=qt($opername."::".$opername) %>, DBG_ASP);

  <% if ($display) { %>
  setenv("DISPLAY", <%=$display%>.c_str(), 1) ;
  <% } %>

  <% if ($title) { %>
  _window_name = <%=$title%>;
  <% } else { %>
  { 
      stringstream s ;
      s << "Streams " << <%=qt($opername)%> << " operator";
      _window_name = s.str( ) ;
  }
  <% } %>

  _skip = <%= $skip %> ;

    SPLLOG(L_TRACE, "Exiting " <%=qt($opername."::".$opername) %>, DBG_ASP);
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
    SPLLOG(L_TRACE, "Entering " <%=qt($opername."::~".$opername) %>, DBG_ASP);

    SPLLOG(L_TRACE, "Exiting " <%=qt($opername."::~".$opername) %>, DBG_ASP);
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
    SPLLOG(L_TRACE, "Entering " <%=qt($opername."::allPortsReady") %>, DBG_ASP);

  create_window(_window_name) ;
      
  createThreads(1); // Create source thread

    SPLLOG(L_TRACE, "Exiting " <%=qt($opername."::allPortsReady") %>, DBG_ASP);
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
    SPLLOG(L_TRACE, "Entering " <%=qt($opername."::prepareToShutdown") %>, DBG_ASP);

  delete_window(_window_name) ;

  _shutdown = true ;

    SPLLOG(L_TRACE, "Exiting " <%=qt($opername."::prepareToShutdown") %>, DBG_ASP);
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx)
{
  SPLLOG(L_TRACE, "Entering " <%=qt($opername."::processOpenCVEvents") %>, DBG_ASP);
  run_event_loop(&_shutdown);
  SPLLOG(L_TRACE, "Exiting " <%=qt($opername."::processOpenCVEvents") %>, DBG_ASP);
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & inTuple, uint32_t port)
{
    SPLLOG(L_TRACE, "Entering " <%=qt($opername."::process") %>, DBG_ASP);

  if (_shutdown) {
    SPLLOG(L_DEBUG, "Discarding frame since shutdown was requested", DBG_ASP) ;
    return ; }

  _image_count++ ;

  if (_skip > 0 && (_image_count % _skip)) {
    SPLLOG(L_DEBUG, "Skipping frame " << _image_count, DBG_ASP) ;
    return ; }

  SPLLOG(L_DEBUG, "Displaying frame " << _image_count, DBG_ASP) ;

  // get the values of the parameters
  const IPort0Type& iport$0 = static_cast<const IPort0Type &>(inTuple);
  const int width = <%=$widthAttribute%>;
  const int height = <%=$heightAttribute%>;
  const int depth = <%=$depthAttribute%>;
  const int channels = <%=$channelsAttribute%>;
  const SPL::list<SPL::uint8> data = <%=$dataAttribute%>;

  // basic safety checks
  if (depth!=IPL_DEPTH_8U) { THROW(SPLRuntimeOperator, "Unsupported image depth: " << IPL_DEPTH2STR(depth)); }
  const int imgSize = width * height * channels;
  const int dataLength = <%=$dataAttribute%>.getSize();
  if (imgSize!=dataLength) { THROW(SPLRuntimeOperator, "image data size does not equal width*height*channels, " << imgSize << " != " << dataLength); }

  // create an OpenCV image header 
  IplImage* img = cvCreateImage(cvSize(width, height), depth, channels);
  if (!img) { THROW(SPLRuntimeOperator, "Unable to create image"); }

  // copy the data from the tuple into the OpenCV image buffer
  uint8_t* srcPointer = (uint8_t*)(&data[0]);
  uint8_t* dstPointer = (uint8_t*)(img->imageData);
  for(int y=0; y<img->height; y++) {
      memcpy(dstPointer, srcPointer, img->width * img->nChannels);
      srcPointer += img->width * img->nChannels;
      dstPointer += img->widthStep; }

  AutoLock<dpssupport::mutex::Mutex> lck(get_toolkit_mutex()) ;

  cvShowImage(_window_name.c_str(), img) ;

  // release the OpenCV image header
  cvReleaseImage(&img) ;

  SPLLOG(L_TRACE, "Exiting " <%=qt($opername."::process") %>, DBG_ASP);
}

<%SPL::CodeGen::implementationEpilogue($model);%>

